
Unbound server configuration
============================

Overview
--------

`Unbound <https://nlnetlabs.nl/projects/unbound/about/>`__ is a validating, recursive, caching DNS resolver. It is available on Linux, \*BSD, OS X and Windows. It is a modern resolver that supports DNSSEC, DNS-over-TLS and DNS-over-HTTPS. It sees increasing use both as a network infra resolver, and as a local secure resolver.


It can be used in two different ways:

- as a Hesiod server, providing local answers to Hesiod queries and forwarding the rest to upstream servers;

- as a DNSSEC-validating recursive resolver on the client system, if your Hesiod zone is signed.

In this document we'll take a look at the first way, the server configuration.



Records and zones
-----------------

Unbound-formatted output is selected with ``OUTPUTFMT="unbound"``.


Unbound supports highly configurable and easily-defined local zones. By default ``hesgen`` will create either a static or a transparent local zone for Hesiod, depending on the parameter ``BLOCKUPSTREAM=``. If another configuration is desired, the parameter ``CREATEZONE=0`` will remove all local zone declaration and print only the TXT records, which can then be inserted in the configuration of your choice.

There is no way of specifying the class for a local zone. They are always created in class IN.

When ``local-data`` RR don't fit in any local zone, unbound will automatically create transparent zones to put them in.

**Warning:** While the automatic transparent zones can be of any class (inferred from the RR), the explicitly-defined zones can only be of class IN. The side effect of that is that you can have either transparent-only zones of any class (which therefore forward any query that can't be answered locally), or IN-only zones of any type. See `HS Class`_ for more details.


The syntax of TXT records is::

    local-data: '<FQDN> [<TTL>|<CLASS>] [<TTL>|<CLASS>] TXT "<RR contents>"'



Server configuration
--------------------

Unbound doesn't require any specific configuration to act as a Hesiod server:

- redirect the output of ``hesgen`` to a file;
- check the contents of the file;
- copy the file to ``/etc/unbound/unbound.conf.d``;
- restart Unbound.
  
In the majority of cases this will be enough to serve Hesiod records.


For debugging issues, you will need these options in your Unbound configuration::

    log-time-ascii: yes
    log-queries: yes
    log-replies: yes  # in recent versions



Blocking
--------

Control of whether Unbound will forward request that are not answerable locally is through the local zone type. Unbound supports multiple local zone types, as decribed in the `documentation <https://nlnetlabs.nl/documentation/unbound/unbound.conf/#local-zone>`__. (**Note**: this is the documentation for the latest version, older versions support fewer types.)

By default ``hesgen`` will create a local zone of type ``static`` for the Hesiod records, and an empty local zone of type ``always_nxdomain`` for the MIT's Athena nameserver. Both of those types will prevent forwarding of locally-unanswerable requests.

This can be disabled with the parameters ``BLOCKATHENA=0`` resp. ``BLOCKUPSTREAM=0``. In 99.9% of cases you will want to keep those two enabled, and block forwarding for those domains.



Examples
--------

The default output for simple ``passwd`` and ``group`` files might look like this::

    # Generated by hesgen on Mon Mar  8 22:30:17 CET 2021
    
    server:
        local-zone: "ns.athena.mit.edu." always_nxdomain
    
        local-zone: "hesiod." static
    
            # Users
            local-data:    'jake.passwd.hesiod.       TXT  "jake:*:5000:5000::/home/jake:/bin/bash"'
            local-data:    '5000.uid.hesiod.          TXT  "jake:*:5000:5000::/home/jake:/bin/bash"'
            local-data:    'elwood.passwd.hesiod.     TXT  "elwood:*:5001:5001::/home/elwood:/bin/bash"'
            local-data:    '5001.uid.hesiod.          TXT  "elwood:*:5001:5001::/home/elwood:/bin/bash"'
            local-data:    'cleophus.passwd.hesiod.   TXT  "cleophus:*:5002:5200::/home/cleophus:/bin/bash"'
            local-data:    '5002.uid.hesiod.          TXT  "cleophus:*:5002:5200::/home/cleophus:/bin/bash"'
    
            # Groups
            local-data:    'jake.group.hesiod.        TXT  "jake:x:5000:"'
            local-data:    '5000.gid.hesiod.          TXT  "jake:x:5000:"'
            local-data:    'elwood.group.hesiod.      TXT  "elwood:x:5001:"'
            local-data:    '5001.gid.hesiod.          TXT  "elwood:x:5001:"'
            local-data:    'orphanage.group.hesiod.   TXT  "orphanage:x:5100:"'
            local-data:    '5100.gid.hesiod.          TXT  "orphanage:x:5100:"'
            local-data:    'triplerock.group.hesiod.  TXT  "triplerock:x:5200:"'
            local-data:    '5200.gid.hesiod.          TXT  "triplerock:x:5200:"'
    
            # Group lists
            local-data:    'jake.grplist.hesiod.      TXT  "5000:5100"'
            local-data:    'elwood.grplist.hesiod.    TXT  "5001:5100"'
            local-data:    'cleophus.grplist.hesiod.  TXT  "5200"'



Notes
-----

With local zones Unbound doesn't support CNAME expansion, so the RR contents need to be repeated.

As of version 1.9.0, Unbound doesn't automatically split long TXT records. When loading a configuration with records leading to answers larger than 512 bytes, it will refuse to start and print this message in the log: ``Conversion error, string expected``.


HS class
~~~~~~~~

Support for HS records in unbound is... peculiar. ``Local-zone:`` definitions are hardcoded to IN (``services/localzone.c``:~745)::

    /** parse local-zone: statements */
    static int
    lz_enter_zones(struct local_zones* zones, struct config_file* cfg) 
    {
        struct config_str2list* p;
        struct local_zone* z;
        for(p = cfg->local_zones; p; p = p->next) {
            if(!(z=lz_enter_zone(zones, p->str, p->str2, 
                LDNS_RR_CLASS_IN)))  <----------------------<<<
                return 0;
            lock_rw_unlock(&z->lock);
        }    
        return 1;
    }

Yet we can put any class in those IN zones, and it will work! You can stuff them with HS records, and Unbound will dutifully answer correctly.

Or so it seems.

Taking the example RRs in `Examples`_, we can check that only one local zone named ``hesiod.`` exists::

    $ sudo unbound-control list_local_zones | grep hesiod
    hesiod. static

Now let's change the first RR (``jake.passwd.hesiod.``) and put it in HS. Restart unbound and check again::

    $ sudo unbound-control list_local_zones | grep hesiod
    hesiod. static
    jake.passwd.hesiod. transparent

Change the next one too (``5000.uid.hesiod.``), restart and check again::

    $ sudo unbound-control list_local_zones | grep hesiod
    hesiod. static
    hesiod. transparent

We can see that unbound created an automatic *transparent* zone for the HS records, with the common domain components of the RRs it contains as name.

Problem one: while the automatic transparent part is mentioned in the docs, the class isn't. Support for non-IN classes in unbound is minimal, not documented and might be pulled out at any time.

Problem two: it's a **transparent** zone, and we have no way to change that. It means that any Hesiod request that can't be answered locally will be forwarded upstream. So by using HS records we lose the ability to keep things local.

The bottom line is: use IN with unbound.

