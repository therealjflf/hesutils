#!/usr/bin/env bash

# ==============================================================================
#
# Functions to parse the passwd and group files.
#
# ==============================================================================
#
# This file is part of Hesutils <https://gitlab.com/jflf/hesutils>
# Hesutils Copyright (c) 2019-2021 JFLF
#
# Hesutils is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Hesutils is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Hesutils. If not, see <https://www.gnu.org/licenses/>.
#
# ==============================================================================



# Parse /etc/passwd
# ------------------------------------------------------------------------------

# /etc/passwd fields:
#  0  user name
#  1  password
#  2  UID
#  3  primary GID
#  4  GECOS
#  5  home directory
#  6  shell

function parse_passwd {

    local delayedwarnings=""

    (( verbose )) && echo -en "\nProcessing the passwd file entries: "

    while IFS=: read -a passwd ; do

        if (( ${passwd[2]} < UIDMIN || UIDMAX < ${passwd[2]} )) ; then
            # user out of Hesiod range, nothing to do
            (( verbose )) && echo -n "x"
            continue
        elif (( ${passwd[3]} < GIDMIN || GIDMAX < ${passwd[3]} )) ; then
            # user is in the Hesiod range, but the primary group isn't
            (( verbose )) && echo -n "!"
            delayedwarnings+="WARNING: Skipping user \"${passwd[0]}\": GID ${passwd[3]} not in range [$GIDMIN-$GIDMAX]\n"
            continue
        else
            # good Hesiod user
            (( verbose )) && echo -n "."
        fi

        # Some distros don't add a given user to its own group in /etc/passwd...
        # (I'm looking at you Debian and derivatives!)
        # We need to add that information in 2 different places:
        # 1. the list of groups a user is a member of
        grplists[${passwd[0]}]=${passwd[3]}
        # 2. the list of users that are member of a given group
        groupmembers[${passwd[3]}]+="${passwd[0]},"

        # Then we need to transform the passwd path into the mount path.
        # This is done inside the FILSYS functions (whether or not FILSYS
        # records are requested), so we do both at the same time.
        filsys_voodoo

        # If needed, do some cleanup.
        # We need to pretend the account is disabled. It's complicated.
        passwd[1]="*"
        # trim the GECOS field if required
        (( TRIMGECOS )) && passwd[4]=

        # and finally, store that user's data
        uid2user[${passwd[2]}]="${passwd[0]}"
        primarygid[${passwd[0]}]=${passwd[3]}
        hesusers[${passwd[0]}]="$(IFS=: ; echo "${passwd[*]}")"

    done < <(awk 'NF && !/^[:space:]*#/' "$HESPASSWDFILE")

    (( verbose )) && echo
    echo -en "$delayedwarnings" >&2

    (( verbose )) && echo -e "  --> ${#hesusers[@]} Hesiod users" || true
}



# Parse /etc/group
# ------------------------------------------------------------------------------

# /etc/group fields:
#  0  group name
#  1  group password (yup, that exists apparently)
#  2  GID
#  3  user list, comma-separated

function parse_group {

    (( verbose )) && echo -n "Processing the group file entries: "

    while IFS=: read -a group ; do

        # only deal with Hesiod groups
        if (( GIDMIN <= ${group[2]} && ${group[2]} <= GIDMAX )) ; then
            (( verbose )) && echo -n "."
        else
            (( verbose )) && echo -n "x"
            continue
        fi

        # check the user list of the group, and add that group GID to the grplist
        # of the Hesiod users that we know of already

        while read -d, member ; do
            # only if we know the user already, and if it's not their primary group
            # (as we added that while parsing the passwd file)
            if [[ " ${!hesusers[@]} " =~ " $member " ]] ; then
                if [[ ${group[2]} != ${primarygid[$member]} ]] ; then
                    grplists[${member}]+=":${group[2]}"
                    groupmembers[${group[2]}]+="${member},"
                fi
            fi
        done < <(echo "${group[3]},")
        # without the comma above ^ the read misses the last member...

        # do we include the full member list?
        if (( FULLMEMBERLIST )) ; then
            group[3]="${groupmembers[${group[2]}]%,}"
        else
            group[3]=
        fi

        # and finally, store that group's data
        gid2group[${group[2]}]=${group[0]}
        hesgroups[${group[0]}]="$(IFS=: ; echo "${group[*]}")"

    done < <(awk 'NF && !/^[:space:]*#/' "$HESGROUPFILE")

    (( verbose )) && echo -e "\n  --> ${#hesgroups[@]} Hesiod groups" || true
}

