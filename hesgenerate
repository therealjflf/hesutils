#!/bin/bash

# ==============================================================================
#
# hesgenerate
#
# ------------------------------------------------------------------------------
#
# Read the information contained in /etc/passwd and /etc/groups, and generate
# DNS configuration files containing Hesiod entries for selected users and
# groups.
# 
# ==============================================================================



# Boilerplate stuff
# ------------------------------------------------------------------------------

# Safety first
set -e -o pipefail

# We deal with "*" and we don't want any expansion
set -o noglob


# The mandatory help message
# ------------------------------------------------------------------------------

function print_help {

    echo "
Usage:  $(basename "$0") -y|-n [options]

Options:

  -h                display this help message and exit
  -v                run in verbose mode
  -y                run: export passwd and group information to Hesiod
  -n                dry run: don't modify files, print to the standard output
  -c <filename>     use an alternative configuration file
  -p <filename>     use an alternative passwd file
  -g <filename>     use an alternative group file

By default this script does nothing. It requires either '-n' or '-y' to run.
Without any parameter this help message is displayed.
" >&2
}


# Without any argument, print the help and exit
if ! (( $# )) ; then
    print_help
    exit 1
fi



# Cleanup function
# ------------------------------------------------------------------------------

function victor {
    # clean any existing redirection to a dns config output file
    { >&3; } 2>/dev/null && exec 3>&-

    [[ -d "$tmpdir" ]] && rm -fr "$tmpdir"
}

trap victor EXIT ERR



# Internal variables
# ------------------------------------------------------------------------------

# The list of library files that we'll load later
libfiles=( lib_utils
           lib_check_cfg_file
           lib_filsys
           lib_passwd_group
           lib_gen_bind
           lib_gen_dnsmasq
           lib_gen_unbound )


# As we can't query /etc/passwd and /etc/group like a database, we'll need a
# bunch of tables to help the lookups that we'll do later.

declare -a uid2user         # index: UID        ->  user name
declare -A hesusers         # index: user name  ->  /etc/passwd string
declare -A primarygid       # index: user name  ->  primary GID
declare -A grplists         # index: user name  ->  GIDs the user belongs to
declare -a gid2group        # index: GID        ->  group name
declare -a groupmembers     # index: GID        ->  user members of that group
declare -A hesgroups        # index: group name ->  /etc/group string
declare -A filsys           # index: user name  ->  filsys record(s)


# We need a temporary directory
tmpdir=$(mktemp -d --tmpdir hesutils.XXXX) || exit 1

declare -i run=0
declare -i verbose=0
declare -i dryrun=0



# Time to parse the parameters
# ------------------------------------------------------------------------------

OPTIND=1
optstring=":hvync:p:g:"

while getopts $optstring name ; do
    case $name in
        h)  print_help
            exit 0
            ;;
        v)  verbose=1
            ;;
        y)  run=1
            dryrun=0
            ;;
        n)  dryrun=1
            run=0
            ;;
        c)  HESCFGFILE="$OPTARG"
            ;;
        p)  HESPASSWDFILE="$OPTARG"
            ;;
        g)  HESGROUPFILE="$OPTARG"
            ;;
        :)  echo "ERROR: The option \"-$OPTARG\" requires a parameter." >&2
            print_help
            exit 1
            ;;
        *)  echo "ERROR: Unknown option: -$OPTARG" >&2
            print_help
            exit 1
    esac
done

# Drop all processed options and leave only the non-option parameters.
# We don't actually need this right now, but we may some day!
shift "$(( OPTIND - 1 ))"


# Did the user ask us to do anything?
if ! (( run + dryrun )) ; then
    echo "ERROR: Neither run (-y) or dry run (-n) was requested, exiting." >&2
    exit 1
fi


# Root is required on a real run, is the user root?
if (( run )) && (( UID )) ; then
    echo "ERROR: This command must be run as root with the '-y' option, exiting." >&2
    exit 1
fi



# Check whether the various hesutils directories and files exist
# ------------------------------------------------------------------------------

# We need to know where we are first
# The PATH hack is needed to work correctly with "bash -x script"
fullpath="$(dirname "$(readlink -f "$(PATH=${PATH}:. which "$0")")")"

if [[ "$fullpath" ]] ; then
    prefix="${fullpath%/bin*}"
else
    # we should always be able to detect our prefix
    # --> this codepath should never be taken!
    echo "WARNING: Could not detect the installation prefix, using default: /usr" >&2
    prefix="/usr"
fi


HESPREFIX="${HESPREFIX:-${prefix}}"
HESLIBPREFIX="${HESLIBPREFIX:-${HESPREFIX}/share/hesutils}"

if ! [[ -d "$HESLIBPREFIX" ]] ; then
    echo "ERROR: The HESLIBPREFIX directory doesn't exist: $HESLIBPREFIX
       See the Hesutils documentation for more details." >&2
    exit 1
fi


# Now that the prefix is known, load the library files
for i in ${libfiles[@]} ; do
    source "${HESLIBPREFIX}/${i}"
done


# Those can be defined via the command line too, which has priority
HESCFGFILE="${HESCFGFILE:-/etc/hesutils.conf}"
HESPASSWDFILE="${HESPASSWDFILE:-/etc/passwd}"
HESGROUPFILE="${HESGROUPFILE:-/etc/group}"

for file in HES{CFG,PASSWD,GROUP}FILE ; do
    if ! [ -r "${!file}" ] ; then
        echo "ERROR: The file doesn't exist or is not readable: ${file}=${!file}" >&2
        exit 1
    fi
done


# Time to display some info
if (( verbose )) ; then
    echo "
Configuration file: $HESCFGFILE
Passwd file:        $HESPASSWDFILE
Group file:         $HESGROUPFILE
"
fi



# Load and check the configuration file
# ------------------------------------------------------------------------------

(( verbose )) && echo "Loading the configuration file"
source "$HESCFGFILE"

(( verbose )) && echo "Checking the configuration file"
check_cfg_file      # exits in case of errors, checks and assigns default values



# Parse the various files to fill in the data arrays
# ------------------------------------------------------------------------------

parse_passwd
parse_group



# Generate the configuration files
# ------------------------------------------------------------------------------

# Generate and install the configuration files, and restart the servers if OK
(( GENDNSMASQ )) && gen_dnsmasq && restart_dnsmasq
(( GENUNBOUND )) && gen_unbound && restart_unbound
(( GENBIND ))    && gen_bind    && restart_bind

# And we're done!

