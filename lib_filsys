#!/bin/bash

# ==============================================================================
# Hesutils library: FILSYS record generation and homedir path transformation
# ==============================================================================


# Run sed commands and generate FILSYSCFG record
# ------------------------------------------------------------------------------

# passwd fields:
#  0  user name
#  1  password
#  2  UID
#  3  primary GID
#  4  GECOS
#  5  home directory
#  6  shell

function sed_filsyscfg {

    local tmp

    # first go through both sed commands
    # the mount path is used both with and without FILSYS

    if [[ "$HOMESEDMOUNT" ]] ; then
        if tmp="$( echo $mountpath | sed "$HOMESEDMOUNT" 2>/dev/null )" ; then
            mountpath="$tmp"
        else
            delayedwarnings+="WARNING: HOMESEDMOUNT sed command failed for user \"${passwd[0]}\", passwd path \"${passwd[5]}\"\n"
        fi
    fi


    if (( FILSYS )) && (( FILSYSCFG )) ; then

        # the export path is only useful for FILSYS setups
        if [[ "$HOMESEDEXPORT" ]] ; then
            if tmp="$( echo $exportpath | sed "$HOMESEDEXPORT" 2>/dev/null )" ; then
                exportpath="$tmp"
            else
                delayedwarnings+="WARNING: HOMESEDEXPORT sed command failed for user \"${passwd[0]}\", passwd path \"${passwd[5]}\"\n"
            fi
        fi

        # generate one FILSYS record using the cfg info
        tmp="$FSTYPE $exportpath "
        [[ "$FSTYPE" == "NFS" ]] && tmp+="$NFSSERVER "
        tmp+="$FSMOUNTOPTS $mountpath"
        filsys[${passwd[0]}]+="${tmp}\n"
    fi
}




# Parse external FILSYS records
# ------------------------------------------------------------------------------

# passwd fields:
#  0  user name
#  1  password
#  2  UID
#  3  primary GID
#  4  GECOS
#  5  home directory
#  6  shell

function parse_external_filsys {

    while read -a record ; do

        # skip empty lines and comments
        ( ! (( ${#record[@]} )) || [[ ${record[0]} =~ ^# ]] ) && continue

        # if we find the keyword "delete", scratch the existing FILSYS entries
        if [[ "${record[1]}" == "delete" ]] ; then
            filsys[${passwd[0]}]=""
            continue
        fi

        # if we have a user-specific record, grab the mount path
        # if there are more than 1 user-specific records, last one wins
        if [[ "${record[0]}" == "${passwd[0]}" ]] ; then
            mountpath="${record[-1]}"
        fi

        # and copy the record over into filsys
        # first field (user name or "*") is skipped
        (( FILSYS )) && filsys[${passwd[0]}]+="${record[@]:1}\n"

    done
}




# Top-level FILSYS voodoo function
# ------------------------------------------------------------------------------

# That function needs to be called even if the user didn't ask for FILSYS
# records, as the code to do the homedir path is part of the FILSYS logic.
#
# The function manipulates variables in the environment:
# passwd    /etc/passwd entries
# filsys    user name  ->  filsys record(s)

# passwd fields:
#  0  user name
#  1  password
#  2  UID
#  3  primary GID
#  4  GECOS
#  5  home directory
#  6  shell

function filsys_voodoo {

    exportpath="${passwd[5]}"
    mountpath="${passwd[5]}"
    filsys[${passwd[0]}]=""


    # first the sed command(s) and the corresponding FILSYS record
    sed_filsyscfg

    # then the contents of the FSMAPFILE
    [[ "$FSMAPFILE" ]] && parse_external_filsys < "$FSMAPFILE"

    # and finally the output of FSCOMMAND
    [[ "$FSCOMMAND" ]] && parse_external_filsys < <( "$FSCOMMAND" "${passwd[@]}" )


    # finally update the home directory to use the mount path
    passwd[5]="$mountpath"
}

