#!/bin/bash

# ==============================================================================
# Hesutils library: parsing of the passwd and group files
# ==============================================================================


# Parse /etc/passwd
# ------------------------------------------------------------------------------

# /etc/passwd fields:
#  0  user name
#  1  password
#  2  UID
#  3  primary GID
#  4  GECOS
#  5  home directory
#  6  shell

function parse_passwd {

    local delayedwarnings=""

    (( verbose )) && echo -en "\nProcessing the passwd file entries: "

    while IFS=: read -a passwd ; do

        if (( ${passwd[2]} < UIDMIN || UIDMAX < ${passwd[2]} )) ; then
            # user out of Hesiod range, nothing to do
            (( verbose )) && echo -n "x"
            continue
        elif (( ${passwd[3]} < GIDMIN || GIDMAX < ${passwd[3]} )) ; then
            # user in in the Hesiod range, but the primary group isn't
            (( verbose )) && echo -n "!"
            delayedwarnings+="WARNING: Skipping user \"${passwd[0]}\": GID ${passwd[3]} not in range [$GIDMIN-$GIDMAX]\n"
            continue
        else
            # good Hesiod user
            (( verbose )) && echo -n "."
        fi

        # start with cleaning up
        # we need to pretend the account is disabled. It's complicated.
        passwd[1]="*"
        # do we need to trim the GECOS field?
        (( TRIMGECOS )) && passwd[4]=

        # some distros don't add a given user to its own group in /etc/passwd...
        # (I'm looking at you Debian and derivatives!)
        # We need to add that information in 2 different places.
        grplists[${passwd[0]}]=${passwd[3]}
        groupmembers[${passwd[3]}]+="${passwd[0]},"

        # do we need to modify the exported home directory?
        [[ "$HOMEDIRSED" ]] && passwd[5]="$(echo "${passwd[5]}" | sed $HOMEDIRSED)"

        # and finally, store that user's data
        uid2user[${passwd[2]}]="${passwd[0]}"
        primarygid[${passwd[0]}]=${passwd[3]}
        hesusers[${passwd[0]}]="$(IFS=: ; echo "${passwd[*]}")"

    done < <(awk '!/^ *#/ && NF' "$HESPASSWDFILE")

    (( verbose )) && echo
    echo -en "$delayedwarnings" >&2

    (( verbose )) && echo -e "  --> ${#hesusers[@]} Hesiod users" || true
}



# Parse /etc/group
# ------------------------------------------------------------------------------

# /etc/group fields:
#  0  group name
#  1  group password (yup, that exists apparently)
#  2  GID
#  3  user list, comma-separated

function parse_group {

    (( verbose )) && echo -n "Processing the group file entries: "

    while IFS=: read -a group ; do

        # only deal with Hesiod groups
        if (( GIDMIN <= ${group[2]} && ${group[2]} <= GIDMAX )) ; then
            (( verbose )) && echo -n "."
        else
            (( verbose )) && echo -n "x"
            continue
        fi

        # check the user list of the group, and add that group GID to the grplist
        # of the Hesiod users that we know of already

        while read -d, member ; do
            # only if we know the user already, and if it's not their primary group
            # (as we added that while parsing the passwd file)
            if [[ " ${!hesusers[@]} " =~ " $member " ]] ; then
                if [[ ${group[2]} != ${primarygid[$member]} ]] ; then
                    grplists[${member}]+=":${group[2]}"
                    groupmembers[${group[2]}]+="${member},"
                fi
            fi
        done < <(echo "${group[3]},")
        # without the comma above ^ the read misses the last member...

        # do we include the full member list?
        if (( FULLMEMBERLIST )) ; then
            group[3]="${groupmembers[${group[2]}]%,}"
        else
            group[3]=
        fi

        # and finally, store that group's data
        gid2group[${group[2]}]=${group[0]}
        hesgroups[${group[0]}]="$(IFS=: ; echo "${group[*]}")"

    done < <(awk '!/^ *#/ && NF' "$HESGROUPFILE")

    (( verbose )) && echo -e "\n  --> ${#hesgroups[@]} Hesiod groups" || true
}

